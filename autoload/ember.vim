"
" This file was automatically generated by riml 0.3.9
" Modify with care!
"
function! s:SID()
  if exists('s:SID_VALUE')
    return s:SID_VALUE
  endif
  let s:SID_VALUE = matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
  return s:SID_VALUE
endfunction

" included: 'version.riml'
let g:ember_extension_version = '0.1.7'
" included: 'controller_name_filter.riml'
function! s:ControllerNameFilterConstructor()
  let controllerNameFilterObj = {}
  let controllerNameFilterObj.set_inflector = function('<SNR>' . s:SID() . '_s:ControllerNameFilter_set_inflector')
  let controllerNameFilterObj.filter = function('<SNR>' . s:SID() . '_s:ControllerNameFilter_filter')
  let controllerNameFilterObj.is_singular = function('<SNR>' . s:SID() . '_s:ControllerNameFilter_is_singular')
  let controllerNameFilterObj.is_plural = function('<SNR>' . s:SID() . '_s:ControllerNameFilter_is_plural')
  let controllerNameFilterObj.get_name_parts = function('<SNR>' . s:SID() . '_s:ControllerNameFilter_get_name_parts')
  return controllerNameFilterObj
endfunction

function! <SID>s:ControllerNameFilter_set_inflector(inflector) dict
  let self.inflector = a:inflector
endfunction

function! <SID>s:ControllerNameFilter_filter(str) dict
  if self.is_singular(a:str)
    return 'ObjectController'
  else
    return 'ArrayController'
  endif
endfunction

function! <SID>s:ControllerNameFilter_is_singular(str) dict
  let parts = self.get_name_parts(a:str)
  if parts.action ==# ''
    let str = parts.base
    let plural = self.inflector.pluralize(str)
    let singular = self.inflector.singularize(plural)
    return singular ==# str
  else
    return parts.action !=# 'index'
  endif
endfunction

function! <SID>s:ControllerNameFilter_is_plural(str) dict
  let parts = self.get_name_parts(a:str)
  if parts.action ==# ''
    let str = parts.base
    let singular = self.inflector.singularize(str)
    let plural = self.inflector.pluralize(singular)
    return plural ==# str
  else
    return parts.action ==# 'index'
  endif
endfunction

function! <SID>s:ControllerNameFilter_get_name_parts(str) dict
  let parts = {}
  if a:str =~# '/'
    let eparts = split(a:str, '/')
    let parts.base = eparts[0]
    let parts.action = eparts[1]
  else
    let parts.base = a:str
    let parts.action = ''
  endif
  return parts
endfunction

" included: 'model_name_filter.riml'
function! s:ModelNameFilterConstructor()
  let modelNameFilterObj = {}
  let modelNameFilterObj.set_inflector = function('<SNR>' . s:SID() . '_s:ModelNameFilter_set_inflector')
  let modelNameFilterObj.filter = function('<SNR>' . s:SID() . '_s:ModelNameFilter_filter')
  let modelNameFilterObj.get_name_parts = function('<SNR>' . s:SID() . '_s:ModelNameFilter_get_name_parts')
  return modelNameFilterObj
endfunction

function! <SID>s:ModelNameFilter_set_inflector(inflector) dict
  let self.inflector = a:inflector
endfunction

function! <SID>s:ModelNameFilter_filter(str) dict
  let parts = self.get_name_parts(a:str)
  let model_name = parts.base
  return self.inflector.singularize(model_name)
endfunction

function! <SID>s:ModelNameFilter_get_name_parts(str) dict
  let parts = {}
  if a:str =~# '/'
    let eparts = split(a:str, '/')
    let parts.base = eparts[0]
    let parts.action = eparts[1]
  else
    let parts.base = a:str
    let parts.action = ''
  endif
  return parts
endfunction

" included: 'ember_extension.riml'
let s:ember_extension_path = expand('<sfile>:h:h')
function! s:EmberExtensionConstructor()
  let emberExtensionObj = {}
  let emberExtensionObj.get_name = function('<SNR>' . s:SID() . '_s:EmberExtension_get_name')
  let emberExtensionObj.get_portkey_path = function('<SNR>' . s:SID() . '_s:EmberExtension_get_portkey_path')
  let emberExtensionObj.get_scope = function('<SNR>' . s:SID() . '_s:EmberExtension_get_scope')
  let emberExtensionObj.get_finder = function('<SNR>' . s:SID() . '_s:EmberExtension_get_finder')
  let emberExtensionObj.get_ranker = function('<SNR>' . s:SID() . '_s:EmberExtension_get_ranker')
  let emberExtensionObj.get_syntax_files = function('<SNR>' . s:SID() . '_s:EmberExtension_get_syntax_files')
  let emberExtensionObj.configure_inflector = function('<SNR>' . s:SID() . '_s:EmberExtension_configure_inflector')
  let emberExtensionObj.configure_projection = function('<SNR>' . s:SID() . '_s:EmberExtension_configure_projection')
  let emberExtensionObj.get_filters = function('<SNR>' . s:SID() . '_s:EmberExtension_get_filters')
  let emberExtensionObj.get_extractors = function('<SNR>' . s:SID() . '_s:EmberExtension_get_extractors')
  return emberExtensionObj
endfunction

function! <SID>s:EmberExtension_get_name() dict
  return 'ember'
endfunction

function! <SID>s:EmberExtension_get_portkey_path(type, variant) dict
  let portkey_type = a:type
  if portkey_type ==# 'custom'
    return 'null'
  endif
  let portkey_variant = a:variant
  if portkey_type ==# ''
    let portkey_type = 'appkit'
  endif
  if portkey_variant ==# ''
    let portkey_variant = 'js'
  endif
  let path = s:ember_extension_path . '/'
  let path .= "portkeys/" . self.get_name() . "/" . portkey_type . "_" . portkey_variant . "_portkey.json"
  return path
endfunction

function! <SID>s:EmberExtension_get_scope() dict
  return 'ember'
endfunction

function! <SID>s:EmberExtension_get_finder(type) dict
  return 0
endfunction

function! <SID>s:EmberExtension_get_ranker(type) dict
  return 0
endfunction

function! <SID>s:EmberExtension_get_syntax_files() dict
  let syntaxes = {}
  let syntaxes['*.js'] = 'syntax/emberjs.vim'
  let syntaxes['*.coffee'] = 'syntax/emberjs.vim'
  return syntaxes
endfunction

function! <SID>s:EmberExtension_configure_inflector(inflector) dict
endfunction

function! <SID>s:EmberExtension_configure_projection(projection) dict
endfunction

function! <SID>s:EmberExtension_get_filters() dict
  let filters = {}
  let filters['cname'] = s:ControllerNameFilterConstructor()
  let filters['mname'] = s:ModelNameFilterConstructor()
  return filters
endfunction

function! <SID>s:EmberExtension_get_extractors() dict
  return []
endfunction

function! ember#get_extension()
  if !(exists('s:extension'))
    let s:extension = s:EmberExtensionConstructor()
  endif
  return s:extension
endfunction
